<!-- 
    based off of tutorials by Mike Mulshine et al
    dependencies are in https://ccrma.stanford.edu/~cc/220a/webchuck220a/
-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!--- make responsive for mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<!--- Include the ACE editor and webchuck stuff -->
  <link rel="stylesheet" href="https://ccrma.stanford.edu/~cc/220a/webchuck220a/css/editor.css">
  <script type="text/javascript" src="https://ccrma.stanford.edu/~cc/220a/webchuck220a/js/ace.js" charset="utf-8"></script>
  <script type="text/javascript" src="https://ccrma.stanford.edu/~cc/220a/webchuck220a/js/editor.js"></script>
  <script type="text/javascript" src="https://ccrma.stanford.edu/~cc/220a/webchuck220a/js/defer.js"></script>
  <script type="text/javascript" src="https://ccrma.stanford.edu/~cc/220a/webchuck220a/js/webchuck_host.js"></script>

</head>

<p>Homework 2 is about synthesizing an auditory streaming illusion using FM tones.
</p>

<h2> Play it (the entire piece...)</h2>
<p>Just click the start button. The IsoRhythm class gets preloaded, a single instance of it gets played once. Then experiment with the suggestion below. The code creates a group of multiple instances that play as overlapping layers (polyphony) and then creates another group.
</p>

//////////////////////////////////////////////////// <br>
suggestion (copy this whole and replace the live code) <br>   
<pre><div id="editor2" class="ace_editor ace_hidpi ace-chuck">
IsoRhythm iso[3];
spork ~iso[0].play(30::second, 0.97, 160::ms);
1::second => now;
spork ~iso[1].play(29::second, 0.96, 150::ms);
1::second => now;
spork ~iso[2].play(48::second, 0.95, 140::ms);
30::second => now;
IsoRhythm iso2[3];
spork ~iso2[0].play(30::second, 0.97, 160::ms);
1::second => now;
spork ~iso2[1].play(29::second, 0.96, 150::ms);
1::second => now;
spork ~iso2[2].play(28::second, 0.95, 140::ms);
30::second => now;
</div></pre>
//////////////////////////////////////////////////// <br>
live code
<pre><div id="editor1" class="ace_editor ace_hidpi ace-chuck">  
// -------------------------------------------------------------
// array to hold midi pitches (key numbers) 
// these will be converted into the carrier frequencies
[60, 62, 64, 65] @=> int keyNum[];

// how many pitches are in the array
keyNum.size() => int nPitches;

// -------------------------------------------------------------
// against a cycle of a different length which we'll use to vary 
// instrument parameters
nPitches - 1 => int nInstruments;

// arrays to hold modulation frequency, timing of modulation envelope, 
// and timing/gain of carrier ADSRs
// really, anything that we want to use to break the repeating pitches
// into multiple streams

// FMFS is a custom class, "FM From Scratch"
// instantiate nInstruments instances of the class
// make arrays for carrier amplitude & carrier amplitude envelope breakpoints, 
// and modulation frequency ratio & index & modulation envelope breakpoints
// ADSR stands for "Attack-Decay-Sustain-Release"
FMFS fm[nInstruments];
float carrierAmp[nInstruments];
float carrierADSR[nInstruments][0]; // 2d array, second dimension will hold an array of float values for ADSR
float pitchRatio[nInstruments];
float modulationRatio[nInstruments];
float modulationIndex[nInstruments];
float modulatorADSR[nInstruments][0];
for (0 => int i; i < nInstruments; i++) 
{
    [1.0,2.0,4.0] @=> pitchRatio;
    1.5 + Math.pow(i,3.1) => modulationRatio[i];
    Math.pow(i,3) => modulationIndex[i];
    [1.0,.04,.5,.1] @=> carrierADSR[i];
    [0.01,.4,1.0,.1] @=> modulatorADSR[i];
    fm[i].out => dac.chan(i%2);
    <<<"instrument",i,": pitchRatio", pitchRatio[i],"  modulationRatio", modulationRatio[i],"  modulationIndex", modulationIndex[i]>>>;
}

// -------------------------------------------------------------
// global parameters

// set a common note duration
100::ms => dur duration;
// initial interOnsetInterval (inverse of tempo)
800::ms => dur interOnsetInterval;
// accelerate to this smallest interOnsetInterval 
160::ms => dur minInterOnsetInterval;
// index for which pitch is next
0 => int p;
// index for which instrument is next                         
0 => int i;


// loop for 20 seconds
now => time beg;
beg + 20::second => time end;

while (now < end) {
    <<< "Pitch (",p,") keyNum =", keyNum[p], "\tInstrument(", i, ")">>>;
    Std.mtof(keyNum[p]+12.0) => float carrierFreq;
    // play the note
    spork ~fm[i].playFM(duration, carrierFreq, pitchRatio[i], carrierADSR[i], modulationRatio[i], modulationIndex[i], modulatorADSR[i]);
    // increment pitch and instrument
    p++;
    i++;
    // cycle pitches through full array
    nPitches %=> p;
    // cycle instruments through full array
    nInstruments %=> i;
    
    // advance time by interOnsetInterval and calculate the next interval
    interOnsetInterval => now;
    // accelerate
    if (interOnsetInterval > minInterOnsetInterval) 
      interOnsetInterval * 0.95 => interOnsetInterval;
      else
    // can't go faster than minInterOnsetInterval 
        minInterOnsetInterval => interOnsetInterval;
}

// -------------------------------------------------------------
// @class FMFS
// fm implementation from scratch with envelopes
// @author 2015 Madeline Huberth, 2022 version by CC
class FMFS
{ // two typical uses of the ADSR envelope unit generator...
    Step unity => ADSR envM => blackhole; //...as a separate signal
    SinOsc mod => blackhole;
    SinOsc car => ADSR envC => Gain out;  //...as an inline modifier of a signal
    car.gain(0.2);
    float freq, index, ratio; // the parameters for our FM patch
    fun void fm() // this patch is where the work is
    {
      while (true)
      {
        envM.last() * index => float currentIndex; // time-varying index
        mod.gain( freq * currentIndex );    // modulator gain (index depends on frequency)
        mod.freq( freq * ratio );           // modulator frequency (a ratio of frequency) 
        car.freq( freq + mod.last() );      // frequency + modulator signal = FM 
        1::samp => now;
      }
    }
    spork ~fm(); // run the FM patch

    // function to play a note on our FM patch
    fun void playFM( dur length, float pitch, float pitchRatio, float carrierADSR[], float modulationRatio, float mGain, float modulatorADSR[] ) 
    {
        // set patch values
        pitchRatio * pitch => freq;
        modulationRatio => ratio;
        mGain => index;
       // run the envelopes
        spork ~ playEnv( envC, length, carrierADSR );
        spork ~ playEnv( envM, length, modulatorADSR );
        length => now; // wait until the note is done
    }

    fun void playEnv( ADSR env, dur length, float adsrValues[] )
    {
        // set values for ADSR envelope depending on length
        length * adsrValues[0] => dur A;
        length * adsrValues[1] => dur D;
        adsrValues[2] => float S;
        length * adsrValues[3] => dur R;
        
        // set up ADSR envelope for this note
        env.set( A, D, S, R );
        // start envelope (attack is first segment)
        env.keyOn();
        // wait through A+D+S, before R
        length-env.releaseTime() => now;
        // trigger release segment
        env.keyOff();
        // wait for release to finish
        env.releaseTime() => now;
    }
    fun void playFMtestTone() 
    { 
      out => dac; // connect output
      playFM(0.9::second, 440.0, 1.0, [.01,.4,.5,.1], 1.0, 10.0, [.01,.4,1.0,.1]);
      out =< dac; // disconnect output
    }    
}  // end of FMFS class definition 



</div></pre>

<p>
<input id="startButton" type="button" value="Start" /> 
<input id="stopButton" type="button" value="Stop" /> <br/><br/>
</p>

<script>
    var preloaded = false;
    var serverFilesToPreload = [
        {
            serverFilename: 'https://ccrma.stanford.edu/~cc/220a/hw2/isoRhythm.ck',
            virtualFilename: 'isoRhythm.ck'
        }
    ];
    async function prep() {
        if (!preloaded) {
          await preloadFilenames( serverFilesToPreload );
        }
        await startChuck();
        await theChuckReady;
        theChuck.removeLastCode();
        if (!preloaded) {
          await theChuck.runFile("isoRhythm.ck");
          preloaded = true;
        }
    }

var editor1 = newChuckEditor("editor1");
var editor2 = newChuckEditor("editor2");
editor2.setOptions({
  showLineNumbers: false
  , showGutter: false
});

var prependCode = `//  none needed
`;

var startButton = document.getElementById( "startButton" );
var stopButton = document.getElementById( "stopButton" );
stopButton.disabled = true;
startButton.style.height = '60px';
startButton.style.width= '120px';
stopButton.style.height = '60px';
stopButton.style.width= '120px';

startButton.addEventListener( "click", async function() {
  await prep();
  await theChuck.runCode(prependCode+editor1.getValue());
  stopButton.disabled = false;
  startButton.value = "Replace";
  await new Promise(r => setTimeout(r, 100));
});

stopButton.addEventListener( "click", async function() {
  await theChuck.removeLastCode();
});

// mouse interface
var clickOn = true;
theChuckReady.then( function() {
  if( window.Event ) { 
    document.captureEvents( Event.MOUSEMOVE );
  }
  document.onmousemove = function( e )  {
      var x = (window.Event) ? e.pageX : event.clientX + (document.documentElement.scrollLeft ?     
        document.documentElement.scrollLeft : document.body.scrollLeft);
      var y = (window.Event) ? e.pageY : event.clientY + (document.documentElement.scrollTop ? 
        document.documentElement.scrollTop : document.body.scrollTop);
//      theChuck.setInt( "mouseX", x );
//      theChuck.setInt( "mouseY", y );
    }
  document.onmousedown = function( e )  {
        theChuck.broadcastEvent("playRiff");
  }
});

</script>
